/*
该项目签署了Apache-2.0 License，详情请参见LICENSE
根据 Apache 许可，版本 2.0（“许可”）获得许可
除非遵守许可，否则您不得使用此文件。

Copyright 2021-2022 花狗Fdog(张旭)
*/

#ifndef FSTRUCT_H
#define FSTRUCT_H

#include "definition.h"
#include <algorithm>
#ifdef __GNUC__
#include <cxxabi.h>
#endif
#include <cstring>
#include <ctime>
#include <deque>
#include <mutex>
#include <map>
#include <map>
#include <list>
#include <sstream>
#include <string>
#include <set>
#include <vector>
#include <regex>
#include <codecvt>
#include <Windows.h>
using namespace std;

//用于数组类型整体提取
const string arrayRegex = "(\\[(.*?)\\])";
//用于Map类型整体提取
const string mapRegex = "(\\{(.*?)\\})";
//匹配数组
const string patternArray = "((A)(\\d+)_\\d?(\\D+))";
//匹配别名
const string patterAlias = "(\\(A:(.*?)\\))";
//用于结构体整体提取
const string objectRegex = "(\\{(.*?)\\})";
//匹配结构体
const string patternObject = "((\\d+)(\\D+))";

enum ObjectType {
	OBJECT_BASE = 1,
	OBJECT_STRUCT,
	OBJECT_CLASS,
	OBJECT_ARRAY,
	OBJECT_VECTOR,
	OBJECT_MAP,
	OBJECT_UNORDERED_MAP,
	OBJECT_LIST,
	OBJECT_SET,
	OBJECT_DEQUE,
};


/***********************************
*   存储结构体元信息
************************************/
typedef struct MetaInfo {
	string memberName;              //成员名
	string memberAliasName;         //成员别名
	string memberType;              //成员类型
	size_t memberOffset;            //偏移值
	size_t memberTypeSize;          //类型大小
	size_t memberArraySize;         //如果类型是数组，表示数组大小
	int    memberTypeInt;           //成员类型 数值型
	bool   isPointer;               //是否是指针
	string first;                   //如果是map类型 first表示key的类型，如果是其他类型，表示value类型
	string second;                  //如果是map类型，second表示value类型
	bool   memberIsIgnore = false;    //是否忽略字段
	bool   memberIsIgnoreLU = false;  //是否忽略大小写                                                                                                                
}MetaInfo;

/***********************************
*   存储对象元信息
************************************/
typedef struct ObjectInfo {
	string objectType;                      //结构体类型 字符串表示
	int objectTypeInt;                      //结构体类型 数值表示
	int objectSize;                         //结构体大小
	vector<MetaInfo *> metaInfoObjectList;  //结构体元信息 
}ObjectInfo;


typedef struct FdogMap {
	string first;
	string second;
};

/***********************************
*   存储成员类型，数组大小
************************************/
struct memberAttribute {
	string valueType;
	int valueTypeInt;   //类型 数值表示
	string first;       //如果是map类型 first表示key的类型，如果是其他类型，表示value类型
	string second;      //如果是map类型，second表示value类型
	int ArraySize;
};

//结构体用于返回信息
struct result {
	int code;           //1.正确 0.错误
	string message;     //如果错误，返回错误提示
};

//声明序列化base类
class FdogSerializerBase {
private:
	static mutex * mutex_base;
	static FdogSerializerBase * FdogSerializerbase;

public:
	static FdogSerializerBase * Instance();

	template<class T>
	string removeLastZero(T & return_) {
		std::ostringstream oss;
		oss << return_;
		return oss.str();
	}

	template<class T>
	string getValueByAddress(string valueType, T & object, int offsetValue) {
		if (valueType == "char*") {
			auto value = *((const char **)((char *)&object + offsetValue));
			string str_value = value;
			return "\"" + str_value + "\"";
		}
		if (valueType == "string") {
			auto value = *((string *)((char *)&object + offsetValue));
			string str_value = value;
			return "\"" + str_value + "\"";
		}
		if (valueType == "wstring") {
			auto value = *((wstring *)((char *)&object + offsetValue));
#ifdef __GNUC__
			wcout << "value = " << value << endl;
			std::wstring_convert<std::codecvt_utf8<wchar_t>> converter;
			string str_value = converter.to_bytes(value);
#elif _MSC_VER
			string str_value = FdogSerializer::Instance()->wstring2string(value);
#endif
			return "\"" + str_value + "\"";
		}
		if (valueType == "bool") {
			auto value = *((bool *)((char *)&object + offsetValue));
			if (value) {
				return "true";
			}
			else {
				return "false";
			}
		}
		if (valueType == "char") {
			auto value = *((char *)((char *)&object + offsetValue));
			return to_string((int)value);
		}
		if (valueType == "unsigned char") {
			auto value = *((char *)((char *)&object + offsetValue));
			return to_string((unsigned int)value);
		}
		if (valueType == "int") {
			//cout << "get = " << (int *)((char *)&object + offsetValue) << endl;
			auto value = *((int *)((char *)&object + offsetValue));
			return to_string(value);
		}
		if (valueType == "unsigned int") {
			auto value = *((unsigned int *)((char *)&object + offsetValue));
			return to_string(value);
		}
		if (valueType == "short") {
			auto value = *((short int *)((char *)&object + offsetValue));
			return to_string(value);
		}
		if (valueType == "unsigned short") {
			auto value = *((unsigned short int *)((char *)&object + offsetValue));
			return to_string(value);
		}
		if (valueType == "long") {
			auto value = *((long int *)((char *)&object + offsetValue));
			return to_string(value);
		}
		if (valueType == "unsigned long") {
			auto value = *((unsigned long int *)((char *)&object + offsetValue));
			return to_string(value);
		}
		if (valueType == "long long") {
			auto value = *((long long int *)((char *)&object + offsetValue));
			return to_string(value);
		}
		if (valueType == "unsigned long long") {
			auto value = *((unsigned long long int *)((char *)&object + offsetValue));
			return to_string(value);
		}
		if (valueType == "float") {
			auto value = *((float *)((char *)&object + offsetValue));
			return removeLastZero(value);
		}
		if (valueType == "double") {
			auto value = *((double *)((char *)&object + offsetValue));
			return removeLastZero(value);
		}
		if (valueType == "long double") {
			auto value = *((long double *)((char *)&object + offsetValue));
			return removeLastZero(value);
		}
		return "";
	}

	template<class T>
	void setValueByAddress(string valueType, T &object, int offsetValue, string value) {
		//cout << "setValueByAddress offsetValue = " << offsetValue << endl;
		if (valueType == "char*") {
			*((char **)((char *)&object + offsetValue)) = new char[strlen(value.c_str())];
			strcpy(*((char **)((char *)&object + offsetValue)), value.c_str());
		}
		if (valueType == "string") {
			*((string *)((char *)&object + offsetValue)) = value;
		}
		if (valueType == "wstring") {
#ifdef __GNUC__
			cout << "检测到wstring" << endl;
			std::wstring_convert< std::codecvt_utf8<wchar_t> > strCnv;
			*((wstring *)((char *)&object + offsetValue)) = strCnv.from_bytes(value);
#elif _MSC_VER
			cout << "检测到wstring" << endl;
			*((wstring *)((char *)&object + offsetValue)) = FdogSerializer::Instance()->string2wstring(value);
#endif
		}
		std::stringstream ss;
		ss.str(value);
		if (valueType == "bool") {
			ss >> *((bool *)((char *)&object + offsetValue));
		}
		if (valueType == "char") {
			ss >> *((char *)((char *)&object + offsetValue));
		}
		if (valueType == "unsigned char") {
			ss >> *((unsigned char *)((char *)&object + offsetValue));
		}
		if (valueType == "int") {
			ss >> *((int *)((char *)&object + offsetValue));
		}
		if (valueType == "unsigned int") {
			ss >> *((unsigned int *)((char *)&object + offsetValue));
		}
		if (valueType == "short") {
			ss >> *((short int *)((char *)&object + offsetValue));
		}
		if (valueType == "unsigned short") {
			ss >> *((unsigned short int *)((char *)&object + offsetValue));
		}
		if (valueType == "long") {
			ss >> *((long int *)((char *)&object + offsetValue));
		}
		if (valueType == "unsigned long") {
			ss >> *((unsigned long int *)((char *)&object + offsetValue));
		}
		if (valueType == "long long") {
			ss >> *((long long int *)((char *)&object + offsetValue));
		}
		if (valueType == "unsigned long long") {
			ss >> *((unsigned long long  int *)((char *)&object + offsetValue));
		}
		if (valueType == "float") {
			ss >> *((float *)((char *)&object + offsetValue));
		}
		if (valueType == "double") {
			ss >> *((double *)((char *)&object + offsetValue));
		}
		if (valueType == "long double") {
			ss >> *((long double *)((char *)&object + offsetValue));
		}
	}

	// 基础类型转json
	template<class T>
	void BaseToJson(string & json_, MetaInfo * metainfoobject, T & object_) {
		//cout << "BaseToJson metainfoobject->memberType = " << metainfoobject->memberType << "&metainfoobject->memberName = " << metainfoobject->memberName << endl;
		string value = getValueByAddress(metainfoobject->memberType, object_, metainfoobject->memberOffset);
		if (metainfoobject->memberAliasName != "") {
			json_ = json_ + "\"" + metainfoobject->memberAliasName + "\"" + ":" + value + ",";
		}
		else {
			json_ = json_ + "\"" + metainfoobject->memberName + "\"" + ":" + value + ",";
		}
	}

	// //基础类型转json
	template<class T>
	void BaseToJsonA(string & json_, MetaInfo * metainfoobject, T & object_) {
		string value = getValueByAddress(metainfoobject->memberType, object_, metainfoobject->memberOffset);
		json_ = json_ + value + ",";
	}

	// //json转基础类型
	template<class T>
	void JsonToBase(T & object_, MetaInfo * metainfoobject, string json_) {
		setValueByAddress(metainfoobject->memberType, object_, metainfoobject->memberOffset, json_);
	}
};


//BaseTag ArrayTag MapTag 用于处理在Serialize，Deserialize上的分发
//处理 base
struct BaseTag {};
//处理 array vector list deque set
struct ArrayTag {};
//处理 map  
struct MapTag {};
//处理 unordered_map
//struct UnorderedMapTag {};

template<typename T> struct TagDispatchTrait {
	using Tag = BaseTag;
};

template<> struct TagDispatchTrait<vector<int>> {
	using Tag = ArrayTag;
};

template<> struct TagDispatchTrait<list<int>> {
	using Tag = ArrayTag;
};

template<> struct TagDispatchTrait<set<int>> {
	using Tag = ArrayTag;
};

template<> struct TagDispatchTrait<deque<int>> {
	using Tag = ArrayTag;
};

template<> struct TagDispatchTrait<map<int, int>> {
	using Tag = MapTag;
};

template<> struct TagDispatchTrait<unordered_map<int, int>> {
	using Tag = MapTag;
};

// 区分非字符串和字符串 处理在FSerialize(map) key的值，可能是数值，可能是非数值
struct NoStringTag {};
struct StringTag {};

template<typename T> struct TagString {
	using Tag = NoStringTag;
};

template<> struct TagString<char *> {
	using Tag = StringTag;
};

template<> struct TagString<string> {
	using Tag = StringTag;
};

template<typename T>
string F_toString_s(T object, NoStringTag) {
	return to_string(object);
}
template<typename T>
string F_toString_s(T object, StringTag) {
	return object;
}
template<typename T>
string F_toString(T object) {
	return F_toString_s(object, typename TagString<T>::Tag{});
}

// 用于反序列化时对象为空的情况，需要根据数据进行扩展长度 Init  分为数值和非数值类型
struct InitBaseTag {};

struct InitVectorTag {};
struct InitVectorStrTag {};

struct InitDequeTag {};
struct InitDequeStrTag {};

struct InitListTag {};
struct InitListStrTag {};

struct InitMapTag {};
struct InitMapStrTag {};

struct InitSetTag {};
struct InitSetStrTag {};


template<typename T> struct TagSTLType {
	using Tag = InitBaseTag;
};

template<> struct TagSTLType<vector<int>> {
	using Tag = InitVectorTag;
};

template<> struct TagSTLType<vector<char *>> {
	using Tag = InitVectorStrTag;
};

template<> struct TagSTLType<vector<string>> {
	using Tag = InitVectorStrTag;
};

template<> struct TagSTLType<list<int>> {
	using Tag = InitListTag;
};

template<> struct TagSTLType<list<char *>> {
	using Tag = InitListStrTag;
};

template<> struct TagSTLType<list<string>> {
	using Tag = InitListStrTag;
};

template<> struct TagSTLType<set<int>> {
	using Tag = InitSetTag;
};

template<> struct TagSTLType<set<char *>> {
	using Tag = InitSetStrTag;
};

template<> struct TagSTLType<set<string>> {
	using Tag = InitSetStrTag;
};

template<> struct TagSTLType<deque<int>> {
	using Tag = InitDequeTag;
};

template<> struct TagSTLType<deque<char *>> {
	using Tag = InitDequeStrTag;
};

template<> struct TagSTLType<deque<string>> {
	using Tag = InitDequeStrTag;
};

template<> struct TagSTLType<map<int, int>> {
	using Tag = InitMapTag;
};

template<> struct TagSTLType<map<string, int>> {
	using Tag = InitMapStrTag;
};

template<> struct TagSTLType<unordered_map<int, int>> {
	using Tag = InitMapTag;
};

template<> struct TagSTLType<unordered_map<string, int>> {
	using Tag = InitMapStrTag;
};

template<typename T>
void F_init_s(T & object, InitBaseTag, string first, string second = "", string key = "") {

}

template<typename T>
void F_init_s(T & object, InitVectorTag, string first, string second = "", string key = "") {
	//cout << " F_init_s object size = " << object.size() << endl;
	if (first == "char") {
		object.push_back('0');
	}
	else if (first == "unsigned char") {
		object.push_back(0);
	}
	else if (first == "short") {
		object.push_back(0);
	}
	else if (first == "unsigned short") {
		object.push_back(0);
	}
	else if (first == "int") {
		object.push_back(0);
	}
	else if (first == "unsigned int") {
		object.push_back(0);
	}
	else if (first == "long") {
		object.push_back(0);
	}
	else if (first == "unsigned long") {
		object.push_back(0);
	}
	else if (first == "long long") {
		object.push_back(0);
	}
	else if (first == "unsigned long long") {
		object.push_back(0);
	}
	else if (first == "float") {
		object.push_back(0.1f);
	}
	else if (first == "double") {
		object.push_back(0.1);
	}
	else if (first == "long double") {
		object.push_back(0.1);
	}
	else {

	}
}

template<typename T>
void F_init_s(T & object, InitVectorStrTag, string first, string second = "", string key = "") {
	if (first == "char*") {
		object.push_back("");
	}
	else if (first == "string") {
		object.push_back("");
	}
	else {

	}
}

template<typename T>
void F_init_s(T & object, InitDequeTag, string first, string second = "", string key = "") {
	if (first == "char") {
		object.push_back('0');
	}
	else if (first == "unsigned char") {
		object.push_back(0);
	}
	else if (first == "short") {
		object.push_back(0);
	}
	else if (first == "unsigned short") {
		object.push_back(0);
	}
	else if (first == "int") {
		object.push_back(0);
	}
	else if (first == "unsigned int") {
		object.push_back(0);
	}
	else if (first == "long") {
		object.push_back(0);
	}
	else if (first == "unsigned long") {
		object.push_back(0);
	}
	else if (first == "long long") {
		object.push_back(0);
	}
	else if (first == "unsigned long long") {
		object.push_back(0);
	}
	else if (first == "float") {
		object.push_back(0.1f);
	}
	else if (first == "double") {
		object.push_back(0.1);
	}
	else if (first == "long double") {
		object.push_back(0.1);
	}
	else {

	}
}

template<typename T>
void F_init_s(T & object, InitDequeStrTag, string first, string second = "", string key = "") {
	if (first == "char*") {
		object.push_back("");
	}
	else if (first == "string") {
		object.push_back("");
	}
	else {

	}
}

template<typename T>
void F_init_s(T & object, InitListTag, string first, string second = "", string key = "") {
	if (first == "int") {
		object.push_back(0);
	}
	if (first == "char") {
		object.push_back('0');
	}
	else if (first == "unsigned char") {
		object.push_back(0);
	}
	else if (first == "short") {
		object.push_back(0);
	}
	else if (first == "unsigned short") {
		object.push_back(0);
	}
	else if (first == "int") {
		object.push_back(0);
	}
	else if (first == "unsigned int") {
		object.push_back(0);
	}
	else if (first == "long") {
		object.push_back(0);
	}
	else if (first == "unsigned long") {
		object.push_back(0);
	}
	else if (first == "long long") {
		object.push_back(0);
	}
	else if (first == "unsigned long long") {
		object.push_back(0);
	}
	else if (first == "float") {
		object.push_back(0.1f);
	}
	else if (first == "double") {
		object.push_back(0.1);
	}
	else if (first == "long double") {
		object.push_back(0.1);
	}
	else {

	}
}

template<typename T>
void F_init_s(T & object, InitListStrTag, string first, string second = "", string key = "") {
	if (first == "char*") {
		object.push_back("");
	}
	else if (first == "string") {
		object.push_back("");
	}
	else {

	}
}

template<typename T>
void F_init_s(T & object, InitSetTag, string first, string second = "", string key = "") {
	//set是不可以重复的，可以拿随机数
	int a = rand() % 100;
	if (first == "int") {
		object.insert(a);
	}
	if (first == "char") {
		stringstream sstr;
		sstr << a;
		object.insert(sstr.str()[0]);
	}
	else if (first == "unsigned char") {
		object.insert(a);
	}
	else if (first == "short") {
		object.insert(a);
	}
	else if (first == "unsigned short") {
		object.insert(a);
	}
	else if (first == "int") {
		object.insert(a);
	}
	else if (first == "unsigned int") {
		object.insert(a);
	}
	else if (first == "long") {
		object.insert(a);
	}
	else if (first == "unsigned long") {
		object.insert(a);
	}
	else if (first == "long long") {
		object.insert(a);
	}
	else if (first == "unsigned long long") {
		object.insert(a);
	}
	else if (first == "float") {
		object.insert(static_cast<float>(a));
	}
	else if (first == "double") {
		object.insert(static_cast<double>(a));
	}
	else if (first == "long double") {
		object.insert(static_cast<long double>(a));
	}
	else {

	}
}

//如果是char * 类型，每次delete之后 地址都是相同的，所以不能在内部使用完归零，要在外面整体赋完值delete
static vector<char *> temp;

template<typename T>
void F_init_s(T & object, InitSetStrTag, string first, string second = "", string key = "") {
	int a = rand() % 100;
	//cout << "a = " << a << endl;
	if (first == "char*") {
		stringstream sstr;
		sstr << a;
		char * cc = new char[4];
		//cout << "cc = " << (char *)cc << "---"<< *cc << "---" << &cc << " sstr 地址：" << &sstr << endl;
		strcpy(cc, (char *)sstr.str().data());
		//cout << "cc = " << (char *)cc << "---"<< *cc << "---" << &cc << " sstr 地址：" << &sstr << endl;
		object.insert(cc);
		temp.push_back(cc);
	}
	else if (first == "string") {
		stringstream sstr;
		sstr << a;
		object.insert((char *)sstr.str().c_str());
	}
	else {

	}
	//cout << "长度：" << object.size() << endl;
}

template<typename T>
void F_init_s(T & object, InitMapTag, string first, string second = "", string key = "") {
	int a = atoi(key.c_str());
	if (first == "int" && second == "int") {
		object.insert(make_pair(a, a));
	}
}

template<typename T>
void F_init_s(T & object, InitMapStrTag, string first, string second = "", string key = "") {
	int a = rand() % 100;
	if (first == "string" && second == "int") {
		stringstream sstr;
		sstr << a;
		//string value = key;
		object.insert(make_pair(key, a));
	}
}

template<typename T>
void F_init(T & object, int stlType, string first, string second = "", string key = "") {

	if (stlType == OBJECT_VECTOR) {
		F_init_s(object, typename TagSTLType<T>::Tag{}, first);
	}
	if (stlType == OBJECT_LIST) {
		F_init_s(object, typename TagSTLType<T>::Tag{}, first);
	}
	if (stlType == OBJECT_DEQUE) {
		F_init_s(object, typename TagSTLType<T>::Tag{}, first);
	}
	if (stlType == OBJECT_SET) {
		F_init_s(object, typename TagSTLType<T>::Tag{}, first);
	}
	if (stlType == OBJECT_MAP) {
		F_init_s(object, typename TagSTLType<T>::Tag{}, first, second, key);
	}
	if (stlType == OBJECT_UNORDERED_MAP) {
		//cout << "%$$$$$$$$ 进入" << endl;
		F_init_s(object, typename TagSTLType<T>::Tag{}, first, second, key);
	}
}

//用于区分(基础类型结构体/数组)
struct BaseAndStructTag {};
struct BaseArrayTag {};

template<typename T> struct TagSTLAAAType {
	using Tag = BaseAndStructTag;
};

// template<> struct TagSTLAAAType<student[2]> {
//     using Tag = BaseArrayTag;
// };

template<> struct TagSTLAAAType<int[2]> {
	using Tag = BaseArrayTag;
};

template<> struct TagSTLAAAType<list<int>> {
	using Tag = BaseAndStructTag;
};

class FdogSerializer {

private:
	static mutex * mutex_serialize;
	static FdogSerializer * fdogSerializer;
	vector<ObjectInfo *> objectInfoList;
	vector<MetaInfo *> baseInfoList;
	vector<string> baseType;
	map<string, string> baseRegex;
	map<int, string> complexRegex;
	map<string, string> TypeName;
	FdogSerializer();
	~FdogSerializer();

public:
	//获取实例
	static FdogSerializer * Instance();

	//添加objectinfo
	void addObjectInfo(ObjectInfo * objectinfo);

	//获取对应Info
	ObjectInfo & getObjectInfo(string objectName);

	//获取对于Info 针对基础类型获取
	MetaInfo * getMetaInfo(string TypeName);

	//针对不同平台获取唯一类型值
	std::string getTypeName(string TypeName);

	//设置别名
	void __setAliasName(string Type, string memberName, string AliasName);
	//移除别名
	void __removeAliasName(string Type, string memberName);

	//设置是否忽略该字段序列化
	void __setIgnoreField(string Type, string memberName);
	//移除忽略字段
	void __removeIgnoreField(string Type, string memberName);

	//设置是否忽略大小写
	void __setIgnoreLU(string Type, string memberName);
	//移除忽略大小写
	void __removeIgnoreLU(string Type, string memberName);

	//设置进行模糊转换 结构体转json不存在这个问题主要是针对json转结构体的问题，如果存在分歧，可以尝试进行模糊转换
	void __setFuzzy(string Type);

	void __setAliasNameS(string Type) {};//退出

										 //一次性设置多个别名  必须对应  类型  原成员名 别名 一旦使用，最少三个参数
	template<class T, class ...Args>
	void __setAliasNameS(T Type, T memberName, T AliasName, Args... args) {
		if (memberName == "" && AliasName == "") {
			//有问题
		}
		//每次获取两个值
		__setAliasName(Type, memberName, AliasName);
		if (sizeof...(args) == 0) {
			return;
		}
		else if ((sizeof...(args) % 2) != 0) {
			//有问题
		}
		__setAliasNameS(Type, args...);
	}

	void __setIgnoreFieldS(string Type) {};//退出

										   //一次性设置忽略多个字段序列化
	template<class T, class ...Args>
	void __setIgnoreFieldS(T Type, T memberName, Args... args) {
		if (memberName == "") {
			//有问题
		}
		//每次获取一个值
		__setIgnoreField(Type, memberName);
		if (sizeof...(args) == 0) {
			return;
		}
		__setIgnoreFieldS(Type, args...);
	}

	void __setIgnoreLUS(string Type) {}//退出

									   //一次性设置忽略多个字段的大小写
	template<class T, class ...Args>
	void __setIgnoreLUS(T Type, T memberName, Args... args) {
		if (memberName == "") {
			//有问题
		}
		//每次获取一个值
		__setIgnoreLU(Type, memberName);
		if (sizeof...(args) == 0) {
			return;
		}
		__setIgnoreLUS(Type, args...);
	}

	//移除第一个逗号
	void removeFirstComma(string & return_);
	//移除最后一个逗号
	void removeLastComma(string & return_);
	//移除数字
	void removeNumbers(string & return_);

	//获取key值
	string getKey(string json);

	//获取成员属性
	memberAttribute getMemberAttribute(string key);

	//获取object类型
	int getObjectTypeInt(string objectName, string typeName);

	//获取基础类型 只有base和struct两种
	ObjectInfo getObjectInfoByType(string typeName, int objectTypeInt);

	wstring string2wstring(string str);

	string wstring2string(wstring wstr);

	//通过宏定义加载的信息获取
	int getObjectTypeByObjectInfo(string objectName);

	//判断是否是基础类型
	bool isBaseType(string typeName);

	//在map的基础上判断是否是基础类型
	bool isBaseTypeByMap(string typeName);

	//判断是否为vector类型
	bool isVectorType(string objectName, string typeName);

	//获取vector中的类型
	string getTypeOfVector(string objectName, string typeName);

	//判断是否为map类型
	bool isMapType(string objectName, string typeName);

	//判断是否为unordered_map类型
	bool isUnorderedMapType(string objectName, string typeName);

	//获取map中的key，value类型
	FdogMap getTypeOfMap(string objectName, string typeName);

	//判断是否是list类型
	bool isListType(string objectName, string typeName);

	//获取list中的类型
	string getTypeOfList(string objectName, string typeName);

	//判断是否是deque类型
	bool isDequeType(string objectName, string typeName);

	//判断是否是set类型
	bool isSetType(string objectName, string typeName);

	//判断是否是结构体类型
	bool isStructType(string objectName, string typeName);

	//判断是否是数组
	bool isArrayType(string objectName, string typeName);

	//解析数组
	vector<string> CuttingArray(string data);

	//切割
	vector<string> split(string str, string pattern);

	//判断json格式是否正确
	//vector<string> CuttingJson(string json_);
	result CuttingJson(vector<string> & array_json, string json_);
	//判断方括号是否匹配
	result IsSquareBracket(string json_);

	//判断花括号是否匹配
	result IsCurlyBraces(string json_);

	//判断总符号数是否匹配
	result isMatch(string json_);

	//判断json正确性
	result __JsonValidS(string json_);

	//判断字段是否存在
	bool __Exist(string json_, string key);

	//获取字段的值
	string __GetStringValue(string json_, string key);

	//获取字段的值
	int __GetIntValue(string json_, string key);

	//获取字段的值
	double __GetDoubleValue(string json_, string key);

	//获取字段的值
	long __GetLongValue(string json_, string key);

	//获取字段的值
	bool __GetBoolValue(string json_, string key);

	//序列化
	template<typename T>
	void Serialize(string & json_, T & object_, string name = "") {
		//cout << "Serialize =" << abi::__cxa_demangle(typeid(T).name(),0,0,0) << endl;
		//通过传进来的T判断是什么复合类型，ObjectInfo只保存结构体,如果是NULL可以确定传进来的不是struct类型
		ObjectInfo objectinfo = FdogSerializer::Instance()->getObjectInfo(FdogSerializer::Instance()->getTypeName(typeid(T).name()));
		//获取的只能是结构体的信息，无法知道是什么复合类型，尝试解析类型 objectType其实是一个结构体类型名称
		int objectType = getObjectTypeInt(objectinfo.objectType, FdogSerializer::Instance()->getTypeName(typeid(T).name()));
		if (objectinfo.objectType == "NULL" && objectType != OBJECT_BASE && objectType != OBJECT_STRUCT) {
			//说明不是struct类型和base类型尝试，尝试解析类型
			objectinfo = getObjectInfoByType(FdogSerializer::Instance()->getTypeName(typeid(T).name()), objectType);
			objectType = getObjectTypeInt(objectinfo.objectType, FdogSerializer::Instance()->getTypeName(typeid(T).name()));
			//这里这个objectinfo应该还是空 所以拿objecttype的数值判断
		}
		int sum = objectinfo.metaInfoObjectList.size();
		//cout << "sum：" << sum << endl;
		int i = 1;
		//获取到的objectType才是真正的类型，根据这个类型进行操作
		//cout << "objectType type = " << objectType  << " json_ : " << json_ << endl;
		switch (objectType) {
			//第一次调用进来表示其本身类型 只有两种 结构体或着基础类型
		case OBJECT_BASE:
		{
			MetaInfo * metainfo1 = nullptr;
			metainfo1 = getMetaInfo(FdogSerializer::Instance()->getTypeName(typeid(object_).name()));
			if (metainfo1 != nullptr) {
				//cout << "==================" << endl;
				FdogSerializerBase::Instance()->BaseToJsonA(json_, metainfo1, object_);
			}
			else {
				//cout << "获取MetaInfo失败" << endl;
			}
		}
		break;
		case OBJECT_STRUCT:
		{
			for (auto metainfoObject : objectinfo.metaInfoObjectList) {
				string json_s;
				//cout <<"成员类型：" << metainfoObject->memberType << " -- " << metainfoObject->memberTypeInt << " -- " << metainfoObject->first <<":" << metainfoObject->second << " -- " << metainfoObject->memberOffset << endl;
				if (metainfoObject->memberTypeInt == OBJECT_BASE && metainfoObject->memberIsIgnore != true) {
					FdogSerializerBase::Instance()->BaseToJson(json_s, metainfoObject, object_);
					json_ = json_ + json_s;
				}
				if (metainfoObject->memberTypeInt == OBJECT_ARRAY && metainfoObject->memberIsIgnore != true) {
					if (metainfoObject->first == "bool") {
						for (int i = 0; i < metainfoObject->memberArraySize; i++) {
							string value = FdogSerializerBase::Instance()->getValueByAddress(metainfoObject->first, object_, metainfoObject->memberOffset + (i * sizeof(bool)));
							json_s = json_s + value + ",";
						}
					}
					if (metainfoObject->first == "char") {
						for (int i = 0; i < metainfoObject->memberArraySize; i++) {
							string value = FdogSerializerBase::Instance()->getValueByAddress(metainfoObject->first, object_, metainfoObject->memberOffset + (i * sizeof(char)));
							json_s = json_s + value + ",";
						}
					}
					if (metainfoObject->first == "unsigned char") {
						for (int i = 0; i < metainfoObject->memberArraySize; i++) {
							string value = FdogSerializerBase::Instance()->getValueByAddress(metainfoObject->first, object_, metainfoObject->memberOffset + (i * sizeof(unsigned char)));
							json_s = json_s + value + ",";
						}
					}
					if (metainfoObject->first == "char*") {
						for (int i = 0; i < metainfoObject->memberArraySize; i++) {
							string value = FdogSerializerBase::Instance()->getValueByAddress(metainfoObject->first, object_, metainfoObject->memberOffset + (i * sizeof(char*)));
							json_s = json_s + value + ",";
						}
					}
					if (metainfoObject->first == "string") {
						for (int i = 0; i < metainfoObject->memberArraySize; i++) {
							string value = FdogSerializerBase::Instance()->getValueByAddress(metainfoObject->first, object_, metainfoObject->memberOffset + (i * sizeof(string)));
							json_s = json_s + value + ",";
						}
					}
					if (metainfoObject->first == "short") {
						for (int i = 0; i < metainfoObject->memberArraySize; i++) {
							string value = FdogSerializerBase::Instance()->getValueByAddress(metainfoObject->first, object_, metainfoObject->memberOffset + (i * sizeof(short)));
							json_s = json_s + value + ",";
						}
					}
					if (metainfoObject->first == "unsigned short") {
						for (int i = 0; i < metainfoObject->memberArraySize; i++) {
							string value = FdogSerializerBase::Instance()->getValueByAddress(metainfoObject->first, object_, metainfoObject->memberOffset + (i * sizeof(unsigned short)));
							json_s = json_s + value + ",";
						}
					}
					if (metainfoObject->first == "int") {
						for (int i = 0; i < metainfoObject->memberArraySize; i++) {
							string value = FdogSerializerBase::Instance()->getValueByAddress(metainfoObject->first, object_, metainfoObject->memberOffset + (i * sizeof(int)));
							json_s = json_s + value + ",";
						}
					}
					if (metainfoObject->first == "unsigned int") {
						for (int i = 0; i < metainfoObject->memberArraySize; i++) {
							string value = FdogSerializerBase::Instance()->getValueByAddress(metainfoObject->first, object_, metainfoObject->memberOffset + (i * sizeof(unsigned int)));
							json_s = json_s + value + ",";
						}
					}
					if (metainfoObject->first == "long") {
						for (int i = 0; i < metainfoObject->memberArraySize; i++) {
							string value = FdogSerializerBase::Instance()->getValueByAddress(metainfoObject->first, object_, metainfoObject->memberOffset + (i * sizeof(long)));
							json_s = json_s + value + ",";
						}
					}
					if (metainfoObject->first == "unsigned long") {
						for (int i = 0; i < metainfoObject->memberArraySize; i++) {
							string value = FdogSerializerBase::Instance()->getValueByAddress(metainfoObject->first, object_, metainfoObject->memberOffset + (i * sizeof(unsigned long)));
							json_s = json_s + value + ",";
						}
					}
					if (metainfoObject->first == "long long") {
						for (int i = 0; i < metainfoObject->memberArraySize; i++) {
							string value = FdogSerializerBase::Instance()->getValueByAddress(metainfoObject->first, object_, metainfoObject->memberOffset + (i * sizeof(long long)));
							json_s = json_s + value + ",";
						}
					}
					if (metainfoObject->first == "unsigned long long") {
						for (int i = 0; i < metainfoObject->memberArraySize; i++) {
							string value = FdogSerializerBase::Instance()->getValueByAddress(metainfoObject->first, object_, metainfoObject->memberOffset + (i * sizeof(unsigned long long)));
							json_s = json_s + value + ",";
						}
					}
					if (metainfoObject->first == "float") {
						for (int i = 0; i < metainfoObject->memberArraySize; i++) {
							string value = FdogSerializerBase::Instance()->getValueByAddress(metainfoObject->first, object_, metainfoObject->memberOffset + (i * sizeof(float)));
							json_s = json_s + value + ",";
						}
					}
					if (metainfoObject->first == "double") {
						for (int i = 0; i < metainfoObject->memberArraySize; i++) {
							string value = FdogSerializerBase::Instance()->getValueByAddress(metainfoObject->first, object_, metainfoObject->memberOffset + (i * sizeof(double)));
							json_s = json_s + value + ",";
						}
					}
					if (metainfoObject->first == "long double") {
						for (int i = 0; i < metainfoObject->memberArraySize; i++) {
							string value = FdogSerializerBase::Instance()->getValueByAddress(metainfoObject->first, object_, metainfoObject->memberOffset + (i * sizeof(long double)));
							json_s = json_s + value + ",";
						}
					}
					//添加容器自定义参数宏
					Serialize_arraytype_judgment_all;

					removeLastComma(json_s);
					json_ = json_ + "\"" + metainfoObject->memberName + "\"" + ":" + "[" + json_s + "]" + ",";
				}
				if (metainfoObject->memberTypeInt == OBJECT_VECTOR && metainfoObject->memberIsIgnore != true) {
					//cout << "====获取的值：" << metainfoObject->first << endl;
					if (metainfoObject->first == "char") {
						FSerialize(json_s, *(vector<char> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<vector<int>>::Tag{});
					}
					if (metainfoObject->first == "unsigned char") {
						FSerialize(json_s, *(vector<unsigned char> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<vector<int>>::Tag{});
					}
					if (metainfoObject->first == "char*") {
						//cout << "zhaodaoleix1" << endl;
						FSerialize(json_s, *(vector<char *> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<vector<int>>::Tag{});
					}
					if (metainfoObject->first == "string") {
						//cout << "zhaodaoleix1" << endl;
						FSerialize(json_s, *(vector<string> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<vector<int>>::Tag{});
					}
					if (metainfoObject->first == "short") {
						FSerialize(json_s, *(vector<short> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<vector<int>>::Tag{});
					}
					if (metainfoObject->first == "unsigned short") {
						FSerialize(json_s, *(vector<unsigned short> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<vector<int>>::Tag{});
					}
					if (metainfoObject->first == "int") {
						FSerialize(json_s, *(vector<int> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<vector<int>>::Tag{});
					}
					if (metainfoObject->first == "unsigned int") {
						FSerialize(json_s, *(vector<unsigned int> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<vector<int>>::Tag{});
					}
					if (metainfoObject->first == "long") {
						FSerialize(json_s, *(vector<long> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<vector<int>>::Tag{});
					}
					if (metainfoObject->first == "unsigned long") {
						FSerialize(json_s, *(vector<unsigned long> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<vector<int>>::Tag{});
					}
					if (metainfoObject->first == "long long") {
						FSerialize(json_s, *(vector<long long> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<vector<int>>::Tag{});
					}
					if (metainfoObject->first == "unsigned long long") {
						FSerialize(json_s, *(vector<unsigned long long> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<vector<int>>::Tag{});
					}
					if (metainfoObject->first == "float") {
						FSerialize(json_s, *(vector<float> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<vector<int>>::Tag{});
					}
					if (metainfoObject->first == "double") {
						FSerialize(json_s, *(vector<double> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<vector<int>>::Tag{});
					}
					if (metainfoObject->first == "long double") {
						FSerialize(json_s, *(vector<long double> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<vector<int>>::Tag{});
					}
					Serialize_vector_type_judgment_all;
					json_ = json_ + "\"" + metainfoObject->memberName + "\"" + ":" + "[" + json_s + "]" + ",";
				}
				if (metainfoObject->memberTypeInt == OBJECT_LIST && metainfoObject->memberIsIgnore != true) {
					//cout << "====获取的值：" << metainfoObject->first << endl;
					if (metainfoObject->first == "bool") {
						FSerialize(json_s, *(list<bool> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<list<bool>>::Tag{});
					}
					if (metainfoObject->first == "char") {
						FSerialize(json_s, *(list<char> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<list<int>>::Tag{});
					}
					if (metainfoObject->first == "unsigned char") {
						FSerialize(json_s, *(list<unsigned char> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<list<int>>::Tag{});
					}
					if (metainfoObject->first == "char*") {
						FSerialize(json_s, *(list<char *> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<list<int>>::Tag{});
					}
					if (metainfoObject->first == "string") {
						FSerialize(json_s, *(list<string> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<list<int>>::Tag{});
					}
					if (metainfoObject->first == "short") {
						FSerialize(json_s, *(list<short> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<list<int>>::Tag{});
					}
					if (metainfoObject->first == "unsigned short") {
						FSerialize(json_s, *(list<unsigned short> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<list<int>>::Tag{});
					}
					if (metainfoObject->first == "int") {
						FSerialize(json_s, *(list<int> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<list<int>>::Tag{});
					}
					if (metainfoObject->first == "unsigned int") {
						FSerialize(json_s, *(list<unsigned int> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<list<int>>::Tag{});
					}
					if (metainfoObject->first == "long") {
						FSerialize(json_s, *(list<long> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<list<int>>::Tag{});
					}
					if (metainfoObject->first == "unsigned long") {
						FSerialize(json_s, *(list<unsigned long> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<list<int>>::Tag{});
					}
					if (metainfoObject->first == "long long") {
						FSerialize(json_s, *(list<long long> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<list<int>>::Tag{});
					}
					if (metainfoObject->first == "unsigned long long") {
						FSerialize(json_s, *(list<unsigned long long> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<list<int>>::Tag{});
					}
					if (metainfoObject->first == "float") {
						FSerialize(json_s, *(list<float> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<list<int>>::Tag{});
					}
					if (metainfoObject->first == "double") {
						FSerialize(json_s, *(list<double> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<list<int>>::Tag{});
					}
					if (metainfoObject->first == "long double") {
						FSerialize(json_s, *(list<long double> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<list<int>>::Tag{});
					}
					Serialize_list_type_judgment_all;
					json_ = json_ + "\"" + metainfoObject->memberName + "\"" + ":" + "[" + json_s + "]" + ",";
				}
				if (metainfoObject->memberTypeInt == OBJECT_DEQUE && metainfoObject->memberIsIgnore != true) {
					if (metainfoObject->first == "bool") {
						FSerialize(json_s, *(deque<bool> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<deque<bool>>::Tag{});
					}
					if (metainfoObject->first == "char") {
						FSerialize(json_s, *(deque<char> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<deque<int>>::Tag{});
					}
					if (metainfoObject->first == "unsigned char") {
						FSerialize(json_s, *(deque<unsigned char> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<deque<int>>::Tag{});
					}
					if (metainfoObject->first == "char*") {
						FSerialize(json_s, *(deque<char *> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<deque<int>>::Tag{});
					}
					if (metainfoObject->first == "string") {
						FSerialize(json_s, *(deque<string> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<deque<int>>::Tag{});
					}
					if (metainfoObject->first == "short") {
						FSerialize(json_s, *(deque<short> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<deque<int>>::Tag{});
					}
					if (metainfoObject->first == "unsigned short") {
						FSerialize(json_s, *(deque<unsigned short> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<deque<int>>::Tag{});
					}
					if (metainfoObject->first == "int") {
						FSerialize(json_s, *(deque<int> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<deque<int>>::Tag{});
					}
					if (metainfoObject->first == "unsigned int") {
						FSerialize(json_s, *(deque<unsigned int> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<deque<int>>::Tag{});
					}
					if (metainfoObject->first == "long") {
						FSerialize(json_s, *(deque<long> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<deque<int>>::Tag{});
					}
					if (metainfoObject->first == "unsigned long") {
						FSerialize(json_s, *(deque<unsigned long> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<deque<int>>::Tag{});
					}
					if (metainfoObject->first == "long long") {
						FSerialize(json_s, *(deque<long long> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<deque<int>>::Tag{});
					}
					if (metainfoObject->first == "unsigned long long") {
						FSerialize(json_s, *(deque<unsigned long long> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<deque<int>>::Tag{});
					}
					if (metainfoObject->first == "float") {
						FSerialize(json_s, *(deque<float> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<deque<int>>::Tag{});
					}
					if (metainfoObject->first == "double") {
						FSerialize(json_s, *(deque<double> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<deque<int>>::Tag{});
					}
					if (metainfoObject->first == "long double") {
						FSerialize(json_s, *(deque<long double> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<deque<int>>::Tag{});
					}
					Serialize_deque_type_judgment_all;
					json_ = json_ + "\"" + metainfoObject->memberName + "\"" + ":" + "[" + json_s + "]" + ",";
				}
				if (metainfoObject->memberTypeInt == OBJECT_SET && metainfoObject->memberIsIgnore != true) {
					if (metainfoObject->first == "bool") {
						FSerialize(json_s, *(set<bool> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<set<bool>>::Tag{});
					}
					if (metainfoObject->first == "char") {
						FSerialize(json_s, *(set<char> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<set<int>>::Tag{});
					}
					if (metainfoObject->first == "unsigned char") {
						FSerialize(json_s, *(set<unsigned char> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<set<int>>::Tag{});
					}
					if (metainfoObject->first == "char*") {
						FSerialize(json_s, *(set<char *> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<set<int>>::Tag{});
					}
					if (metainfoObject->first == "string") {
						FSerialize(json_s, *(set<string> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<set<int>>::Tag{});
					}
					if (metainfoObject->first == "short") {
						FSerialize(json_s, *(set<short> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<set<int>>::Tag{});
					}
					if (metainfoObject->first == "unsigned short") {
						FSerialize(json_s, *(set<unsigned short> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<set<int>>::Tag{});
					}
					if (metainfoObject->first == "int") {
						FSerialize(json_s, *(set<int> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<set<int>>::Tag{});
					}
					if (metainfoObject->first == "unsigned int") {
						FSerialize(json_s, *(set<unsigned int> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<set<int>>::Tag{});
					}
					if (metainfoObject->first == "long") {
						FSerialize(json_s, *(set<long> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<set<int>>::Tag{});
					}
					if (metainfoObject->first == "unsigned long") {
						FSerialize(json_s, *(set<unsigned long> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<set<int>>::Tag{});
					}
					if (metainfoObject->first == "long long") {
						FSerialize(json_s, *(set<long long> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<set<int>>::Tag{});
					}
					if (metainfoObject->first == "unsigned long long") {
						FSerialize(json_s, *(set<unsigned long long> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<set<int>>::Tag{});
					}
					if (metainfoObject->first == "float") {
						FSerialize(json_s, *(set<float> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<set<int>>::Tag{});
					}
					if (metainfoObject->first == "double") {
						FSerialize(json_s, *(set<double> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<set<int>>::Tag{});
					}
					if (metainfoObject->first == "long double") {
						FSerialize(json_s, *(set<long double> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<set<int>>::Tag{});
					}
					Serialize_set_type_judgment_all;
					json_ = json_ + "\"" + metainfoObject->memberName + "\"" + ":" + "[" + json_s + "]" + ",";
				}
				if (metainfoObject->memberTypeInt == OBJECT_MAP && metainfoObject->memberIsIgnore != true) {
					if (metainfoObject->first == "char*" && metainfoObject->second == "int") {
						FSerialize(json_s, *(map<char *, int> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<map<int, int>>::Tag{});
					}
					if (metainfoObject->first == "string" && metainfoObject->second == "int") {
						FSerialize(json_s, *(map<string, int> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<map<int, int>>::Tag{});
					}
					if (metainfoObject->first == "string" && metainfoObject->second == "float") {
						FSerialize(json_s, *(map<string, float> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<map<int, int>>::Tag{});
					}
					if (metainfoObject->first == "string" && metainfoObject->second == "bool") {
						FSerialize(json_s, *(map<string, int> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<map<int, int>>::Tag{});
					}
					if (metainfoObject->first == "int" && metainfoObject->second == "int") {
						FSerialize(json_s, *(map<int, int> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<map<int, int>>::Tag{});
					}
					Serialize_map_type_judgment_all;
					json_ = json_ + "\"" + metainfoObject->memberName + "\"" + ":" + "{" + json_s + "}" + ",";
				}
				if (metainfoObject->memberTypeInt == OBJECT_UNORDERED_MAP && metainfoObject->memberIsIgnore != true) {
					//cout << "走OBJECT_UNORDERED_MAP" << endl;
					if (metainfoObject->first == "char*" && metainfoObject->second == "int") {
						FSerialize(json_s, *(unordered_map<char *, int> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<unordered_map<int, int>>::Tag{});
					}
					if (metainfoObject->first == "string" && metainfoObject->second == "int") {
						FSerialize(json_s, *(unordered_map<string, int> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<unordered_map<int, int>>::Tag{});
					}
					if (metainfoObject->first == "string" && metainfoObject->second == "float") {
						FSerialize(json_s, *(unordered_map<string, float> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<unordered_map<int, int>>::Tag{});
					}
					if (metainfoObject->first == "string" && metainfoObject->second == "bool") {
						FSerialize(json_s, *(unordered_map<string, int> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<unordered_map<int, int>>::Tag{});
					}
					if (metainfoObject->first == "int" && metainfoObject->second == "int") {
						FSerialize(json_s, *(unordered_map<int, int> *)((char *)&object_ + metainfoObject->memberOffset), TagDispatchTrait<unordered_map<int, int>>::Tag{});
					}
					Serialize_map_type_judgment_all;
					json_ = json_ + "\"" + metainfoObject->memberName + "\"" + ":" + "{" + json_s + "}" + ",";
				}
				//还需要添加容器自定义参数宏
				//这个宏用于进入OBJECT_STRUCT
				Serialize_type_judgment_all;
				if (i == sum) {
					if (json_.length() > 0) {
						removeLastComma(json_);
					}
				}
				json_s = "";
				i++;
			}
		}
		break;
		//后续增加基础STL类型
		//普通map需要在这里定义
		//处理直接是STL类型
		}
	}

	template<typename T>
	void SerializeS(string & json_, T & object_, BaseAndStructTag, string name = "") {
		//cout << "SerializeS1" << endl;
		Serialize(json_, object_, name);
	}

	template<typename T>
	void SerializeS(string & json_, T & object_, BaseArrayTag, string name = "") {
		//cout << "SerializeS2" << endl;
		for (auto & object_one : object_) {
			Serialize(json_, object_one);
		}
	}

	template<typename T>
	void SerializeS_s(string & json_, T & object_, bool isArray, string name = "") {
		// if(isArray){
		//     SerializeS(json_, object_, TagSTLAAAType<int[2]>::Tag{}, name);
		// }else{
		// SerializeS(json_, object_, TagSTLAAAType<list<int>>::Tag{}, name);
		// }
		SerializeS(json_, object_, typename TagSTLAAAType<T>::Tag{}, name);
	}


	//用于解析基础类型，数组(只需要判断有没有[]就能确定是不是数组，结构体和基础类型都不具备[]条件)，结构体
	template<typename T>
	void FSerialize(string & json_, T & object_, BaseTag, string name = "") {
		bool isArray = isArrayType("", FdogSerializer::Instance()->getTypeName(typeid(T).name()));
		//cout << "是否是数组 ： " << isArray << endl;
		SerializeS_s(json_, object_, isArray, name);
		//Serialize(json_, object_, name);
		//这里需要判断类型 如果是基础类型直接使用name 不是基础类型，可以使用
		if (isBaseType(FdogSerializer::Instance()->getTypeName(typeid(T).name()))) {
			removeLastComma(json_);
			json_ = "{\"" + name + "\":" + json_ + "}";
			return;
		}
		if (isArrayType("", FdogSerializer::Instance()->getTypeName(typeid(T).name()))) {
			removeLastComma(json_);
			json_ = "{\"" + name + "\":" + "[" + json_ + "]" + "}";
			return;
		}
		json_ = "{" + json_ + "}";
	}
	//用于解析STL（map除外）其实上面接口也可以处理vector，但其他类型无法处理，所以这个处理STL
	template<typename T>
	void FSerialize(string & json_, T & object_, ArrayTag, string name = "") {
		//cout << "进入array==========1" << typeid(T).name() << endl;
		for (auto & object_one : object_) {
			//ji
			int objectType = isBaseType(FdogSerializer::Instance()->getTypeName(typeid(object_one).name()));
			if (!objectType) {
				json_ = json_ + "{";
			}
			//cout << "1=====" << endl;
			Serialize(json_, object_one);
			//cout << "进入array==========2" << typeid(object_one).name() << endl;
			if (!objectType) {
				json_ = json_ + "},";
			}
		}
		if (json_.length() > 0) {
			removeLastComma(json_);
		}
		//json_ = "{\"" + name + "\":[" + json_ + "]}";
		//如果转换对象直接就是数组，可以再额外提供一个，或者说其他
	}
	//用于解析map
	template<typename T>
	void FSerialize(string & json_, T & object_, MapTag, string name = "") {
		int i = 0;
		int len = object_.size();
		for (auto & object_one : object_) {
			//看情况，如果是结构体，需要花括号，基本类型不需要
			json_ = json_ + "\"" + F_toString(object_one.first) + "\"" + ":";
			Serialize(json_, object_one.second);
			removeLastComma(json_);
			json_ = json_ + ",";
			i++;
		}
		removeLastComma(json_);
		//json_ = "{" + json_ + "}";
	}

	//用于解析unordered_map
	// template<typename T>
	// void FSerialize(string & json_, T & object_, UnorderedMapTag, string name = ""){
	//     int i = 0;
	//     int len = object_.size();
	//     for(auto & object_one : object_){
	//         //看情况，如果是结构体，需要花括号，基本类型不需要
	//         json_ = json_ + "\"" + F_toString(object_one.first) + "\"" + ":";
	//         Serialize(json_, object_one.second);
	//         removeLastComma(json_);
	//         json_ = json_ + ",";
	//         i++;
	//     }
	//     removeLastComma(json_);
	//     //json_ = "{" + json_ + "}";
	// }

	//反序列化
	template<typename T>
	void Deserialize(T & object_, string & json_, string name = "") {
		//cout << "Deserialize json_ = " << json_ << endl; 
		ObjectInfo & objectinfo = FdogSerializer::Instance()->getObjectInfo(FdogSerializer::Instance()->getTypeName(typeid(T).name()));
		int objectType = getObjectTypeInt(objectinfo.objectType, FdogSerializer::Instance()->getTypeName(typeid(T).name()));
		if (objectinfo.objectType == "NULL" && objectType != OBJECT_BASE && objectType != OBJECT_STRUCT) {
			//说明不是struct类型和base类型尝试，尝试解析类型
			objectinfo = getObjectInfoByType(FdogSerializer::Instance()->getTypeName(typeid(T).name()), objectType);
			objectType = getObjectTypeInt(objectinfo.objectType, FdogSerializer::Instance()->getTypeName(typeid(T).name()));
		}
		if (OBJECT_BASE == objectType) {
			MetaInfo * metainfo1 = getMetaInfo(FdogSerializer::Instance()->getTypeName(typeid(object_).name()));
			smatch result;
			string regex_key;
			string regex_value = baseRegex[metainfo1->memberType];
			regex * pattern;
			if (name == "") {
				pattern = new regex(regex_value);
			}
			else {
				pattern = new regex(regex_key + ":" + regex_value);
				// if (metainfoObject->memberIsIgnoreLU == false){
				//     pattern = new regex(regex_key + ":" +regex_value);
				// }else{
				//     pattern = new regex(regex_key + ":" +regex_value,regex::icase);//icase用于忽略大小写
				// }
			}
			//cout << "       反序列化获取的regex_value：" << regex_value << "  memberType = " << metainfo1->memberType << endl;
			if (regex_search(json_, result, *pattern)) {
				string value = result.str(2).c_str();
				if (value == "") {
					value = result.str(1).c_str();
				}
				//cout << "@@@@@@@@@@@@@反序列化value = " << value << endl;
				FdogSerializerBase::Instance()->JsonToBase(object_, metainfo1, value);
			}
		}

		if (OBJECT_STRUCT == objectType) {
			for (auto metainfoObject : objectinfo.metaInfoObjectList) {
				//通过正则表达式获取对应的json
				smatch result;
				string regex_key = "(\"" + metainfoObject->memberName + "\")";
				string regex_value = baseRegex[metainfoObject->memberType];
				cout << "       反序列化获取的regex_value：" << regex_value << "  memberType = " << metainfoObject->memberType << endl;
				if (regex_value == "") {
					if (metainfoObject->memberTypeInt == OBJECT_STRUCT) {
						//cout << "------------" << "struct类型" << endl;
						regex_value = objectRegex;
					}
					if (metainfoObject->memberTypeInt == OBJECT_ARRAY) {
						//cout << "------------" << "appay类型" << endl;
						regex_value = arrayRegex;
					}
					if (metainfoObject->memberTypeInt == OBJECT_VECTOR) {
						//cout << "------------" << "vector类型" << endl;
						regex_value = arrayRegex;
					}
					if (metainfoObject->memberTypeInt == OBJECT_LIST) {
						//cout << "------------" << "list类型" << endl;
						regex_value = arrayRegex;
					}
					if (metainfoObject->memberTypeInt == OBJECT_SET) {
						//cout << "------------" << "set类型" << endl;
						regex_value = arrayRegex;
					}
					if (metainfoObject->memberTypeInt == OBJECT_DEQUE) {
						//cout << "------------" << "deque类型" << endl;
						regex_value = arrayRegex;
					}
					if (metainfoObject->memberTypeInt == OBJECT_MAP) {
						//cout << "------------" << "map类型" << endl;
						regex_value = mapRegex;
					}
					if (metainfoObject->memberTypeInt == OBJECT_UNORDERED_MAP) {
						//cout << "------------" << "map类型" << endl;
						regex_value = mapRegex;
					}
				}
				else {
					//cout << "------------" << "base类型" << endl;
				}
				//根据大小写判断
				regex * pattern = nullptr;
				if (metainfoObject->memberIsIgnoreLU == false) {
					pattern = new regex(regex_key + ":" + regex_value);
				}
				else {
					pattern = new regex(regex_key + ":" + regex_value, regex::icase);//icase用于忽略大小写
				}
				if (regex_search(json_, result, *pattern)) {
					string value = result.str(2).c_str();
					//cout << endl << "正则表达式 获取的值：" << value << "   type = " << metainfoObject->memberTypeInt << endl;
					if (metainfoObject->memberTypeInt == OBJECT_BASE && metainfoObject->memberIsIgnore != true) {
						//cout << "反序列化进入base：" << value << endl << endl;
						FdogSerializerBase::Instance()->JsonToBase(object_, metainfoObject, value);
					}
					if (metainfoObject->memberTypeInt == OBJECT_ARRAY && metainfoObject->memberIsIgnore != true) {
						vector<string> json_array;
						objectType = isBaseType(metainfoObject->first);
						if (objectType) {
							smatch result;
							regex pattern(arrayRegex);
							if (regex_search(json_, result, pattern)) {
								string value = result.str(2).c_str();
								json_array = split(value, ",");
							}
						}
						else {
							removeFirstComma(json_);
							removeLastComma(json_);
							json_array = FdogSerializer::Instance()->CuttingArray(json_);
						}
						int j = 0;
						if (metainfoObject->first == "bool") {
							for (int i = 0; i < metainfoObject->memberArraySize; i++) {
								FdogSerializerBase::Instance()->setValueByAddress(metainfoObject->first, object_, metainfoObject->memberOffset + (i * sizeof(bool)), json_array[j++]);
							}
						}
						if (metainfoObject->first == "char") {
							for (int i = 0; i < metainfoObject->memberArraySize; i++) {
								FdogSerializerBase::Instance()->setValueByAddress(metainfoObject->first, object_, metainfoObject->memberOffset + (i * sizeof(char)), json_array[j++]);
							}
						}
						if (metainfoObject->first == "unsigned char") {
							for (int i = 0; i < metainfoObject->memberArraySize; i++) {
								FdogSerializerBase::Instance()->setValueByAddress(metainfoObject->first, object_, metainfoObject->memberOffset + (i * sizeof(unsigned char)), json_array[j++]);
							}
						}
						if (metainfoObject->first == "char*") {
							for (int i = 0; i < metainfoObject->memberArraySize; i++) {
								FdogSerializerBase::Instance()->setValueByAddress(metainfoObject->first, object_, metainfoObject->memberOffset + (i * sizeof(char*)), json_array[j++]);
							}
						}
						if (metainfoObject->first == "string") {
							for (int i = 0; i < metainfoObject->memberArraySize; i++) {
								FdogSerializerBase::Instance()->setValueByAddress(metainfoObject->first, object_, metainfoObject->memberOffset + (i * sizeof(string)), json_array[j++]);
							}
						}
						if (metainfoObject->first == "short") {
							for (int i = 0; i < metainfoObject->memberArraySize; i++) {
								FdogSerializerBase::Instance()->setValueByAddress(metainfoObject->first, object_, metainfoObject->memberOffset + (i * sizeof(short)), json_array[j++]);
							}
						}
						if (metainfoObject->first == "unsigned short") {
							for (int i = 0; i < metainfoObject->memberArraySize; i++) {
								FdogSerializerBase::Instance()->setValueByAddress(metainfoObject->first, object_, metainfoObject->memberOffset + (i * sizeof(unsigned short)), json_array[j++]);
							}
						}
						if (metainfoObject->first == "int") {
							for (int i = 0; i < metainfoObject->memberArraySize; i++) {
								FdogSerializerBase::Instance()->setValueByAddress(metainfoObject->first, object_, metainfoObject->memberOffset + (i * sizeof(int)), json_array[j++]);

							}
						}
						if (metainfoObject->first == "unsigned int") {
							for (int i = 0; i < metainfoObject->memberArraySize; i++) {
								FdogSerializerBase::Instance()->setValueByAddress(metainfoObject->first, object_, metainfoObject->memberOffset + (i * sizeof(unsigned int)), json_array[j++]);
							}
						}
						if (metainfoObject->first == "long") {
							for (int i = 0; i < metainfoObject->memberArraySize; i++) {
								FdogSerializerBase::Instance()->setValueByAddress(metainfoObject->first, object_, metainfoObject->memberOffset + (i * sizeof(long)), json_array[j++]);
							}
						}
						if (metainfoObject->first == "unsigned long") {
							for (int i = 0; i < metainfoObject->memberArraySize; i++) {
								FdogSerializerBase::Instance()->setValueByAddress(metainfoObject->first, object_, metainfoObject->memberOffset + (i * sizeof(unsigned long)), json_array[j++]);
							}
						}
						if (metainfoObject->first == "long long") {
							for (int i = 0; i < metainfoObject->memberArraySize; i++) {
								FdogSerializerBase::Instance()->setValueByAddress(metainfoObject->first, object_, metainfoObject->memberOffset + (i * sizeof(long long)), json_array[j++]);
							}
						}
						if (metainfoObject->first == "unsigned long long") {
							for (int i = 0; i < metainfoObject->memberArraySize; i++) {
								FdogSerializerBase::Instance()->setValueByAddress(metainfoObject->first, object_, metainfoObject->memberOffset + (i * sizeof(unsigned long long)), json_array[j++]);
							}
						}
						if (metainfoObject->first == "float") {
							for (int i = 0; i < metainfoObject->memberArraySize; i++) {
								FdogSerializerBase::Instance()->setValueByAddress(metainfoObject->first, object_, metainfoObject->memberOffset + (i * sizeof(float)), json_array[j++]);
							}
						}
						if (metainfoObject->first == "double") {
							for (int i = 0; i < metainfoObject->memberArraySize; i++) {
								FdogSerializerBase::Instance()->setValueByAddress(metainfoObject->first, object_, metainfoObject->memberOffset + (i * sizeof(double)), json_array[j++]);
							}
						}
						if (metainfoObject->first == "long double") {
							for (int i = 0; i < metainfoObject->memberArraySize; i++) {
								FdogSerializerBase::Instance()->setValueByAddress(metainfoObject->first, object_, metainfoObject->memberOffset + (i * sizeof(long double)), json_array[j++]);
							}
						}
						Deserialize_arraytype_judgment_all;
					}
					if (metainfoObject->memberTypeInt == OBJECT_VECTOR && metainfoObject->memberIsIgnore != true) {
						if (metainfoObject->first == "char") {
							FDeserialize(*(vector<char> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<vector<int>>::Tag{});
						}
						if (metainfoObject->first == "unsigned char") {
							FDeserialize(*(vector<unsigned char> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<vector<int>>::Tag{});
						}
						if (metainfoObject->first == "char*") {
							FDeserialize(*(vector<char *> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<vector<int>>::Tag{});
						}
						if (metainfoObject->first == "string") {
							//cout << "进入string" << endl;
							FDeserialize(*(vector<string> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<vector<int>>::Tag{});
						}
						if (metainfoObject->first == "short") {
							FDeserialize(*(vector<short> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<vector<int>>::Tag{});
						}
						if (metainfoObject->first == "unsigned short") {
							FDeserialize(*(vector<unsigned short> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<vector<int>>::Tag{});
						}
						if (metainfoObject->first == "int") {
							FDeserialize(*(vector<int> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<vector<int>>::Tag{});
						}
						if (metainfoObject->first == "unsigned int") {
							FDeserialize(*(vector<unsigned int> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<vector<int>>::Tag{});
						}
						if (metainfoObject->first == "long") {
							FDeserialize(*(vector<long> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<vector<int>>::Tag{});
						}
						if (metainfoObject->first == "unsigned long") {
							FDeserialize(*(vector<unsigned long> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<vector<int>>::Tag{});
						}
						if (metainfoObject->first == "long long") {
							FDeserialize(*(vector<long long> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<vector<int>>::Tag{});
						}
						if (metainfoObject->first == "unsigned long long") {
							FDeserialize(*(vector<unsigned long long> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<vector<int>>::Tag{});
						}
						if (metainfoObject->first == "float") {
							FDeserialize(*(vector<float> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<vector<int>>::Tag{});
						}
						if (metainfoObject->first == "double") {
							FDeserialize(*(vector<double> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<vector<int>>::Tag{});
						}
						if (metainfoObject->first == "long double") {
							FDeserialize(*(vector<long double> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<vector<int>>::Tag{});
						}
						Deserialize_vector_type_judgment_all;
					}
					if (metainfoObject->memberTypeInt == OBJECT_LIST && metainfoObject->memberIsIgnore != true) {
						if (metainfoObject->first == "bool") {
							FDeserialize(*(list<bool> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<list<bool>>::Tag{});
						}
						if (metainfoObject->first == "char") {
							FDeserialize(*(list<char> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<list<int>>::Tag{});
						}
						if (metainfoObject->first == "unsigned char") {
							FDeserialize(*(list<unsigned char> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<list<int>>::Tag{});
						}
						if (metainfoObject->first == "char*") {
							FDeserialize(*(list<char *> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<list<int>>::Tag{});
						}
						if (metainfoObject->first == "string") {
							FDeserialize(*(list<string> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<list<int>>::Tag{});
						}
						if (metainfoObject->first == "short") {
							FDeserialize(*(list<short> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<list<int>>::Tag{});
						}
						if (metainfoObject->first == "unsigned short") {
							FDeserialize(*(list<unsigned short> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<list<int>>::Tag{});
						}
						if (metainfoObject->first == "int") {
							//cout << "dasdsa======进入list" << endl;                        
							FDeserialize(*(list<int> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<list<int>>::Tag{});
						}
						if (metainfoObject->first == "unsigned int") {
							FDeserialize(*(list<unsigned int> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<list<int>>::Tag{});
						}
						if (metainfoObject->first == "long") {
							FDeserialize(*(list<long> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<list<int>>::Tag{});
						}
						if (metainfoObject->first == "unsigned long") {
							FDeserialize(*(list<unsigned long> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<list<int>>::Tag{});
						}
						if (metainfoObject->first == "long long") {
							FDeserialize(*(list<long long> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<list<int>>::Tag{});
						}
						if (metainfoObject->first == "unsigned long long") {
							FDeserialize(*(list<unsigned long long> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<list<int>>::Tag{});
						}
						if (metainfoObject->first == "float") {
							FDeserialize(*(list<float> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<list<int>>::Tag{});
						}
						if (metainfoObject->first == "double") {
							FDeserialize(*(list<double> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<list<int>>::Tag{});
						}
						if (metainfoObject->first == "long double") {
							FDeserialize(*(list<long double> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<list<int>>::Tag{});
						}
						Deserialize_list_type_judgment_all;
					}
					if (metainfoObject->memberTypeInt == OBJECT_DEQUE && metainfoObject->memberIsIgnore != true) {
						if (metainfoObject->first == "bool") {
							FDeserialize(*(deque<bool> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<deque<bool>>::Tag{});
						}
						if (metainfoObject->first == "char") {
							FDeserialize(*(deque<char> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<deque<int>>::Tag{});
						}
						if (metainfoObject->first == "unsigned char") {
							FDeserialize(*(deque<unsigned char> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<deque<int>>::Tag{});
						}
						if (metainfoObject->first == "char*") {
							FDeserialize(*(deque<char *> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<deque<int>>::Tag{});
						}
						if (metainfoObject->first == "string") {
							FDeserialize(*(deque<string> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<deque<int>>::Tag{});
						}
						if (metainfoObject->first == "short") {
							FDeserialize(*(deque<short> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<deque<int>>::Tag{});
						}
						if (metainfoObject->first == "unsigned short") {
							FDeserialize(*(deque<unsigned short> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<deque<int>>::Tag{});
						}
						if (metainfoObject->first == "int") {
							FDeserialize(*(deque<int> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<deque<int>>::Tag{});
						}
						if (metainfoObject->first == "unsigned int") {
							FDeserialize(*(deque<unsigned int> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<deque<int>>::Tag{});
						}
						if (metainfoObject->first == "long") {
							FDeserialize(*(deque<long> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<deque<int>>::Tag{});
						}
						if (metainfoObject->first == "unsigned long") {
							FDeserialize(*(deque<unsigned long> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<deque<int>>::Tag{});
						}
						if (metainfoObject->first == "long long") {
							FDeserialize(*(deque<long long> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<deque<int>>::Tag{});
						}
						if (metainfoObject->first == "unsigned long long") {
							FDeserialize(*(deque<unsigned long long> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<deque<int>>::Tag{});
						}
						if (metainfoObject->first == "float") {
							FDeserialize(*(deque<float> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<deque<int>>::Tag{});
						}
						if (metainfoObject->first == "double") {
							FDeserialize(*(deque<double> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<deque<int>>::Tag{});
						}
						if (metainfoObject->first == "long double") {
							FDeserialize(*(deque<long double> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<deque<int>>::Tag{});
						}
						Deserialize_deque_type_judgment_all;
					}
					if (metainfoObject->memberTypeInt == OBJECT_SET && metainfoObject->memberIsIgnore != true) {
						if (metainfoObject->first == "bool") {
							FDeserialize(*(set<bool> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<set<bool>>::Tag{});
						}
						if (metainfoObject->first == "char") {
							FDeserialize(*(set<char> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<set<int>>::Tag{});
						}
						if (metainfoObject->first == "unsigned char") {
							FDeserialize(*(set<unsigned char> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<set<int>>::Tag{});
						}
						if (metainfoObject->first == "char*") {
							FDeserialize(*(set<char *> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<set<int>>::Tag{});
						}
						if (metainfoObject->first == "string") {
							FDeserialize(*(set<string> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<set<int>>::Tag{});
						}
						if (metainfoObject->first == "short") {
							FDeserialize(*(set<short> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<set<int>>::Tag{});
						}
						if (metainfoObject->first == "unsigned short") {
							FDeserialize(*(set<unsigned short> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<set<int>>::Tag{});
						}
						if (metainfoObject->first == "int") {
							FDeserialize(*(set<int> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<set<int>>::Tag{});
						}
						if (metainfoObject->first == "unsigned int") {
							FDeserialize(*(set<unsigned int> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<set<int>>::Tag{});
						}
						if (metainfoObject->first == "long") {
							FDeserialize(*(set<long> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<set<int>>::Tag{});
						}
						if (metainfoObject->first == "unsigned long") {
							FDeserialize(*(set<unsigned long> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<set<int>>::Tag{});
						}
						if (metainfoObject->first == "long long") {
							FDeserialize(*(set<long long> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<set<int>>::Tag{});
						}
						if (metainfoObject->first == "unsigned long long") {
							FDeserialize(*(set<unsigned long long> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<set<int>>::Tag{});
						}
						if (metainfoObject->first == "float") {
							FDeserialize(*(set<float> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<set<int>>::Tag{});
						}
						if (metainfoObject->first == "double") {
							FDeserialize(*(set<double> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<set<int>>::Tag{});
						}
						if (metainfoObject->first == "long double") {
							FDeserialize(*(set<long double> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<set<int>>::Tag{});
						}
						Deserialize_set_type_judgment_all;
					}
					if (metainfoObject->memberTypeInt == OBJECT_MAP && metainfoObject->memberIsIgnore != true) {
						if (metainfoObject->first == "char*" && metainfoObject->second == "int") {
							FDeserialize(*(map<char *, int> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<map<int, int>>::Tag{});
						}
						if (metainfoObject->first == "string" && metainfoObject->second == "int") {
							FDeserialize(*(map<string, int> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<map<int, int>>::Tag{});
						}
						if (metainfoObject->first == "string" && metainfoObject->second == "float") {
							FDeserialize(*(map<string, float> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<map<int, int>>::Tag{});
						}
						if (metainfoObject->first == "string" && metainfoObject->second == "bool") {
							FDeserialize(*(map<string, int> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<map<int, int>>::Tag{});
						}
						if (metainfoObject->first == "int" && metainfoObject->second == "int") {
							FDeserialize(*(map<int, int> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<map<int, int>>::Tag{});
						}
						Deserialize_map_type_judgment_all;
					}
					if (metainfoObject->memberTypeInt == OBJECT_UNORDERED_MAP && metainfoObject->memberIsIgnore != true) {
						if (metainfoObject->first == "char*" && metainfoObject->second == "int") {
							FDeserialize(*(unordered_map<char *, int> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<unordered_map<int, int>>::Tag{});
						}
						if (metainfoObject->first == "string" && metainfoObject->second == "int") {
							FDeserialize(*(unordered_map<string, int> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<unordered_map<int, int>>::Tag{});
						}
						if (metainfoObject->first == "string" && metainfoObject->second == "float") {
							FDeserialize(*(unordered_map<string, float> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<unordered_map<int, int>>::Tag{});
						}
						if (metainfoObject->first == "string" && metainfoObject->second == "bool") {
							FDeserialize(*(unordered_map<string, int> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<unordered_map<int, int>>::Tag{});
						}
						if (metainfoObject->first == "int" && metainfoObject->second == "int") {
							FDeserialize(*(unordered_map<int, int> *)((char *)&object_ + metainfoObject->memberOffset), value, TagDispatchTrait<unordered_map<int, int>>::Tag{});
						}
						Deserialize_map_type_judgment_all;
					}
					Deserialize_type_judgment_all;
				}
			}
		}
	}

	template<typename T>
	void DeserializeS(string & json_, T & object_, BaseAndStructTag, string name = "") {
		//cout << "DeserializeS BaseAndStructTag json_ = " << json_ << endl;
		Deserialize(object_, json_, name);
	}

	template<typename T>
	void DeserializeS(string & json_, T & object_, BaseArrayTag, string name = "") {
		vector<string> json_array;
		json_array = FdogSerializer::Instance()->CuttingArray(json_);
		//cout << "----" << json_array.size() << endl;
		for (auto & object_one : object_) {
			Deserialize(object_one, json_);
		}
	}

	template<typename T>
	void DeserializeS_s(T & object_, string & json_, bool isArray, string name = "") {
		// if(isArray){
		//     DeserializeS(json_, object_, TagSTLAAAType<int[2]>::Tag{}, name);
		// }else{

		DeserializeS(json_, object_, typename TagSTLAAAType<T>::Tag{}, name);
		//}
	}

	//用于解析基础类型，数组(只需要判断有没有[]就能确定是不是数组，结构体和基础类型都不具备[]条件)，结构体
	template<typename T>
	void FDeserialize(T & object_, string & json_, BaseTag, string name = "") {
		//cout << "FDeserialize BaseTag json_ = " << json_ << endl;
		bool isArray = isArrayType("", FdogSerializer::Instance()->getTypeName(typeid(T).name()));
		DeserializeS_s(object_, json_, isArray, name);
	}

	//用于解析STL（map除外）
	template<typename T>
	void FDeserialize(T & object_, string & json_, ArrayTag, string name = "") {
		//cout << "FDeserialize ArrayTag json_ = " << json_ << endl;
		//cout << "反序列化进入~array：" << json_  << endl;
		//cout << "类型" << abi::__cxa_demangle(typeid(object_).name(),0,0,0) << endl << endl;
		//cout << "长度 = " << object_.size() << endl;
		int objectType = -1;
		//这个循环进不去
		for (auto & object_one : object_) {
			//判断内部类型是否为基础类型
			objectType = isBaseType(FdogSerializer::Instance()->getTypeName(typeid(object_one).name()));
			//cout << "objectType=" << objectType << "--" << abi::__cxa_demangle(typeid(object_one).name(),0,0,0)<< endl;
			break;
		}
		//cout << "走到这里1"<<endl;
		vector<string> json_array;
		if (objectType) {
			smatch result;
			regex pattern(arrayRegex);
			if (regex_search(json_, result, pattern)) {
				string value = result.str(2).c_str();
				json_array = split(value, ",");
			}
		}
		else {
			removeFirstComma(json_);
			removeLastComma(json_);
			json_array = FdogSerializer::Instance()->CuttingArray(json_);
		}
		//cout << "走到这里2"<<endl;
		int i = 0;
		//这里需要注意，进来的STL容器长度为0，需要重新指定长度 需要想办法
		//需要知道容易内部类型，然后作为参数传进去,如果长度小于需要转换的，就需要添加长度,STL有扩容机制
		int len = json_array.size();
		int len2 = object_.size();
		//cout << "changdu:" << len  << "----" << len2 << endl;
		memberAttribute Member = getMemberAttribute(FdogSerializer::Instance()->getTypeName(typeid(T).name()));
		srand((int)time(NULL)); //用于set
		for (int i = 0; i < json_array.size(); i++) {
			//cout << "xunhuan1 :" << i << " & object_.size() = " << object_.size() << endl;
			if (json_array.size() > object_.size()) {
				F_init(object_, Member.valueTypeInt, Member.first);
				//cout << "xunhuan2 :" << i << " & object_.size() = " << object_.size() << endl;
			}
			//cout << "xunhuan2 :" << i << " & object_.size() = " << object_.size() << endl;
		}
		//cout << "走到这里3 size = " << object_.size() <<endl;
		for (auto & object_one : object_) {
			//cout << "start " << endl;
			//cout << "json_array[i] = " << json_array[i] << endl;
			//cout << "end " << endl;
			Deserialize(object_one, json_array[i]);
			i++;
		}
		//cout << "走到这里4"<<endl;
		//这里释放init里面申请的内存
		if (1) {
			vector<char *>::iterator it = temp.begin();
			while (it != temp.end()) {
				delete *it;
				++it;
			}
		}
		//cout << "走到这里5"<<endl;
		temp.clear();
		//cout << "走到这里6"<<endl;
	}
	//用于map
	template<typename T>
	void FDeserialize(T & object_, string & json_, MapTag) {
		//cout << "反序列化进入~map：" << json_ << endl;
		//cout << "类型" << abi::__cxa_demangle(typeid(object_).name(),0,0,0) << endl << endl;
		int objectType = -1;
		for (auto & object_one : object_) {
			//判断内部类型是否为基础类型
			objectType = isBaseTypeByMap(FdogSerializer::Instance()->getTypeName(typeid(object_one).name()));
			//cout << "objectType=" << objectType << "--" << abi::__cxa_demangle(typeid(object_one).name(),0,0,0)<< endl;
			break;
		}
		//这里有问题 objectType永远为0 找第二种方法
		vector<string> json_array;
		if (objectType) {
			smatch result;
			regex pattern(mapRegex);
			if (regex_search(json_, result, pattern)) {
				string value = result.str(2).c_str();
				json_array = split(value, ",");
			}
		}
		else {
			removeFirstComma(json_);
			removeLastComma(json_);
			json_array = FdogSerializer::Instance()->CuttingArray(json_);
		}
		int i = 0;
		int len = json_array.size();
		sort(json_array.begin(), json_array.end());
		//cout << "changdu:" << len << endl;
		memberAttribute Member = getMemberAttribute(FdogSerializer::Instance()->getTypeName(typeid(T).name()));
		for (int i = 0; i < json_array.size(); i++) {
			if (json_array.size() > object_.size()) {
				//cout <<"##### 进入" << endl;
				F_init(object_, Member.valueTypeInt, Member.first, Member.second, getKey(json_array[i]));
			}
			//i++;
		}
		//这里有个问题，就是可能key的顺序不匹配
		//这里存在问题，进来的STL容器长度为0，需要重新指定长度
		for (auto & object_one : object_) {
			//cout << "进来啦 object_one.second = " << object_one.second << " json_array[i] = " << json_array[i] << endl;
			//提取key:
			//object_one.first = getKey(json_array[i]);
			Deserialize(object_one.second, json_array[i]);
			i++;
		}
		//这里释放init里面申请的内存
		if (Member.valueTypeInt == OBJECT_MAP) {
			vector<char *>::iterator it = temp.begin();
			while (it != temp.end()) {
				delete *it;
				++it;
			}
		}
		temp.clear();
	}
};

namespace Fdog {

	template<typename T>
	void FJson(string & json_, T & object_, string name = "") {
		FdogSerializer::Instance()->FSerialize(json_, object_, typename TagDispatchTrait<T>::Tag{}, name);
	}

	template<typename T>
	void FObject(T & object_, string & json_, string name = "") {
		//cout << "FObject json_ = " << json_ << endl;
		FdogSerializer::Instance()->FDeserialize(object_, json_, typename TagDispatchTrait<T>::Tag{}, name);
	}

	template<typename T>
	std::string FJsonToString(T & object_, string json_ = "", string name = "") {
		FdogSerializer::Instance()->FSerialize(json_, object_, typename TagDispatchTrait<T>::Tag{}, name);
		return json_;
	}

	//设置别名
	void setAliasName(string Type, string memberName, string AliasName);

	//设置多个别名
	template<class T, class ...Args>
	void setAliasNameS(T Type, T memberName, T AliasName, Args... args) {
		FdogSerializer::Instance()->__setAliasNameS(Type, memberName, AliasName, args...);
	}

	//设置是否忽略该字段序列化
	void setIgnoreField(string Type, string memberName);

	//设置多个忽略字段序列化
	template<class T, class ...Args>
	void setIgnoreFieldS(T Type, T memberName, Args... args) {
		FdogSerializer::Instance()->__setIgnoreFieldS(Type, memberName, args...);
	}

	//设置是否忽略大小写
	void setIgnoreLU(string Type, string memberName);

	//设置多个忽略大小写
	template<class T, class ...Args>
	void setIgnoreLUS(T Type, T memberName, Args... args) {
		FdogSerializer::Instance()->__setIgnoreLUS(Type, memberName, args...);
	}

	//设置进行模糊转换 结构体转json不存在这个问题主要是针对json转结构体的问题，如果存在分歧，可以尝试进行模糊转换
	void setFuzzy(string Type);

	//判断json正确性
	result JsonValidS(string json_);

	//判断字段是否存在
	bool Exist(string json_, string key);

	//获取字段的值
	string GetStringValue(string json_, string key);

	//获取字段的值
	int GetIntValue(string json_, string key);

	//获取字段的值
	double GetDoubleValue(string json_, string key);

	//获取字段的值
	long GetLongValue(string json_, string key);

	//获取字段的值
	bool GetBoolValue(string json_, string key);

}

#define EXPAND(...) __VA_ARGS__  //1g

#define NAME_MSVC(x) #x

#define NAME(...) EXPAND(NAME_MSVC(__VA_ARGS__))

#define EXTAND_ARGS(args) args //__VA_ARGS__ 在vs中会被认为是一个实参，所以需要定义该宏过渡

#define ARG_N(...) \
    EXTAND_ARGS(ARG_N_(0, __VA_ARGS__, ARG_N_RESQ()))

#define ARG_N_(...) \
    EXTAND_ARGS(ARG_N_M(__VA_ARGS__))  //2g

#define ARG_N_M(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9,_10, _11, _12, _13, _14, _15, _16, _17, _18, _19,_20, N,...) N

#define ARG_N_RESQ() 20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0

#define MEMBERTYPE(TYPE, MEMBER) FdogSerializer::Instance()->getMemberAttribute(FdogSerializer::Instance()->getTypeName(typeid(((TYPE *)0)->MEMBER).name()));

#define PLACEHOLDER(placeholder, ...) placeholder

#define REGISTERED_FUCK_MSVC(TYPE, ...) \
do{ \
    ObjectInfo * objectinfo_one = new ObjectInfo();\
    objectinfo_one->objectType = NAME(TYPE);\
    objectinfo_one->objectTypeInt = FdogSerializer::Instance()->getObjectTypeInt(objectinfo_one->objectType, FdogSerializer::Instance()->getTypeName(typeid(TYPE).name()));\
    objectinfo_one->objectSize = sizeof(TYPE);\
    FdogSerializer::Instance()->addObjectInfo(objectinfo_one);\
	EXPAND(REGISTEREDMEMBER_s_1_MSVC(TYPE, PLACEHOLDER(__VA_ARGS__), objectinfo_one->metaInfoObjectList, ARG_N(__VA_ARGS__) - 1, __VA_ARGS__, PLACEHOLDER(##__VA_ARGS__)));\
}while(0); //3g //4g   //    //5g

#define REGISTEREDMEMBER(...) EXPAND(REGISTERED_FUCK_MSVC(##__VA_ARGS__))

#define REGISTEREDMEMBER_s_1(TYPE, PLACE, metaInfoObjectList, size, arg1, ...) \
REGISTEREDMEMBER_s(TYPE, metaInfoObjectList, arg1); if (size > 0) EXPAND(REGISTEREDMEMBER_s_2(TYPE, PLACE, metaInfoObjectList, size-1, ##__VA_ARGS__, PLACE));

#define REGISTEREDMEMBER_s_1_MSVC(...) EXPAND(REGISTEREDMEMBER_s_1(##__VA_ARGS__))

#define REGISTEREDMEMBER_s_2(TYPE, PLACE, metaInfoObjectList, size, arg1, ...) \
REGISTEREDMEMBER_s(TYPE, metaInfoObjectList, arg1); if (size > 0) EXPAND(REGISTEREDMEMBER_s_3(TYPE, PLACE, metaInfoObjectList, size-1, ##__VA_ARGS__, PLACE));

#define REGISTEREDMEMBER_s_3(TYPE, PLACE, metaInfoObjectList, size, arg1, ...) \
REGISTEREDMEMBER_s(TYPE, metaInfoObjectList, arg1); if (size > 0) EXPAND(REGISTEREDMEMBER_s_4(TYPE, PLACE, metaInfoObjectList, size-1, ##__VA_ARGS__, PLACE));

#define REGISTEREDMEMBER_s_4(TYPE, PLACE, metaInfoObjectList, size, arg1, ...) \
REGISTEREDMEMBER_s(TYPE, metaInfoObjectList, arg1); if (size > 0) EXPAND(REGISTEREDMEMBER_s_5(TYPE, PLACE, metaInfoObjectList, size-1, ##__VA_ARGS__, PLACE));

#define REGISTEREDMEMBER_s_5(TYPE, PLACE, metaInfoObjectList, size, arg1, ...) \
REGISTEREDMEMBER_s(TYPE, metaInfoObjectList, arg1); if (size > 0) EXPAND(REGISTEREDMEMBER_s_6(TYPE, PLACE, metaInfoObjectList, size-1, ##__VA_ARGS__, PLACE));

#define REGISTEREDMEMBER_s_6(TYPE, PLACE, metaInfoObjectList, size, arg1, ...) \
REGISTEREDMEMBER_s(TYPE, metaInfoObjectList, arg1); if (size > 0) EXPAND(REGISTEREDMEMBER_s_7(TYPE, PLACE, metaInfoObjectList, size-1, ##__VA_ARGS__, PLACE));

#define REGISTEREDMEMBER_s_7(TYPE, PLACE, metaInfoObjectList, size, arg1, ...) \
REGISTEREDMEMBER_s(TYPE, metaInfoObjectList, arg1); if (size > 0) EXPAND(REGISTEREDMEMBER_s_8(TYPE, PLACE, metaInfoObjectList, size-1, ##__VA_ARGS__, PLACE));

#define REGISTEREDMEMBER_s_8(TYPE, PLACE, metaInfoObjectList, size, arg1, ...) \
REGISTEREDMEMBER_s(TYPE, metaInfoObjectList, arg1); if (size > 0) EXPAND(REGISTEREDMEMBER_s_9(TYPE, PLACE, metaInfoObjectList, size-1, ##__VA_ARGS__, PLACE));

#define REGISTEREDMEMBER_s_9(TYPE, PLACE, metaInfoObjectList, size, arg1, ...) \
REGISTEREDMEMBER_s(TYPE, metaInfoObjectList, arg1); if (size > 0) EXPAND(REGISTEREDMEMBER_s_10(TYPE, PLACE, metaInfoObjectList, size-1, ##__VA_ARGS__, PLACE));

#define REGISTEREDMEMBER_s_10(TYPE, PLACE, metaInfoObjectList, size, arg1, ...) \
REGISTEREDMEMBER_s(TYPE, metaInfoObjectList, arg1); if (size > 0) EXPAND(REGISTEREDMEMBER_s_11(TYPE, PLACE, metaInfoObjectList, size-1, ##__VA_ARGS__, PLACE));

#define REGISTEREDMEMBER_s_11(TYPE, PLACE, metaInfoObjectList, size, arg1, ...) \
REGISTEREDMEMBER_s(TYPE, metaInfoObjectList, arg1); if (size > 0) EXPAND(REGISTEREDMEMBER_s_12(TYPE, PLACE, metaInfoObjectList, size-1, ##__VA_ARGS__, PLACE));

#define REGISTEREDMEMBER_s_12(TYPE, PLACE, metaInfoObjectList, size, arg1, ...) \
REGISTEREDMEMBER_s(TYPE, metaInfoObjectList, arg1); if (size > 0) EXPAND(REGISTEREDMEMBER_s_13(TYPE, PLACE, metaInfoObjectList, size-1, ##__VA_ARGS__, PLACE));

#define REGISTEREDMEMBER_s_13(TYPE, PLACE, metaInfoObjectList, size, arg1, ...) \
REGISTEREDMEMBER_s(TYPE, metaInfoObjectList, arg1); if (size > 0) EXPAND(REGISTEREDMEMBER_s_14(TYPE, PLACE, metaInfoObjectList, size-1, ##__VA_ARGS__, PLACE));

#define REGISTEREDMEMBER_s_14(TYPE, PLACE, metaInfoObjectList, size, arg1, ...) \
REGISTEREDMEMBER_s(TYPE, metaInfoObjectList, arg1); if (size > 0) EXPAND(REGISTEREDMEMBER_s_15(TYPE, PLACE, metaInfoObjectList, size-1, ##__VA_ARGS__, PLACE));

#define REGISTEREDMEMBER_s_15(TYPE, PLACE, metaInfoObjectList, size, arg1, ...) \
REGISTEREDMEMBER_s(TYPE, metaInfoObjectList, arg1); if (size > 0) EXPAND(REGISTEREDMEMBER_s_16(TYPE, PLACE, metaInfoObjectList, size-1, ##__VA_ARGS__, PLACE));

#define REGISTEREDMEMBER_s_16(TYPE, PLACE, metaInfoObjectList, size, arg1, ...) \
REGISTEREDMEMBER_s(TYPE, metaInfoObjectList, arg1); if (size > 0) EXPAND(REGISTEREDMEMBER_s_17(TYPE, PLACE, metaInfoObjectList, size-1, ##__VA_ARGS__, PLACE));

#define REGISTEREDMEMBER_s_17(TYPE, PLACE, metaInfoObjectList, size, arg1, ...) \
REGISTEREDMEMBER_s(TYPE, metaInfoObjectList, arg1); if (size > 0) EXPAND(REGISTEREDMEMBER_s_18(TYPE, PLACE, metaInfoObjectList, size-1, ##__VA_ARGS__, PLACE));

#define REGISTEREDMEMBER_s_18(TYPE, PLACE, metaInfoObjectList, size, arg1, ...) \
REGISTEREDMEMBER_s(TYPE, metaInfoObjectList, arg1); if (size > 0) EXPAND(REGISTEREDMEMBER_s_19(TYPE, PLACE, metaInfoObjectList, size-1, ##__VA_ARGS__, PLACE));

#define REGISTEREDMEMBER_s_19(TYPE, PLACE, metaInfoObjectList, size, arg1, ...) \
REGISTEREDMEMBER_s(TYPE, metaInfoObjectList, arg1); if (size > 0) EXPAND(REGISTEREDMEMBER_s_20(TYPE, PLACE, metaInfoObjectList, size-1, ##__VA_ARGS__, PLACE));

#define REGISTEREDMEMBER_s_20(TYPE, PLACE, metaInfoObjectList, size, arg1, ...) \
REGISTEREDMEMBER_s(TYPE, metaInfoObjectList, arg1);

#define offsetof_MSVC(...) EXPAND(offsetof(##__VA_ARGS__));

#define MEMBERTYPE_MSVC(...) EXPAND(MEMBERTYPE(##__VA_ARGS__));

#define REGISTEREDMEMBER_s(TYPE, metaInfoObjectList, arg) \
    do{\
        MetaInfo * metainfo_one = new MetaInfo();\
        metainfo_one->memberName = NAME(arg);\
        metainfo_one->memberAliasName = "";\
        metainfo_one->memberOffset = offsetof_MSVC(TYPE, arg);\
        memberAttribute resReturn = MEMBERTYPE_MSVC(TYPE, arg);\
        metainfo_one->memberType = resReturn.valueType;\
        metainfo_one->memberTypeSize = sizeof(TYPE);\
        metainfo_one->memberArraySize = resReturn.ArraySize;\
        metainfo_one->memberTypeInt = resReturn.valueTypeInt;\
        metainfo_one->first = resReturn.first;\
        metainfo_one->second = resReturn.second;\
        metainfo_one->memberIsIgnore = false;\
        metainfo_one->memberIsIgnoreLU = false;\
        metaInfoObjectList.push_back(metainfo_one);\
    }while(0);

#endif